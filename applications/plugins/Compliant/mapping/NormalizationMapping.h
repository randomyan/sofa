#ifndef NormalizationMAPPING_H
#define NormalizationMAPPING_H

#include <Compliant/config.h>

#include "AssembledMapping.h"
#include "AssembledMultiMapping.h"

namespace sofa
{
	
namespace component
{

namespace mapping
{


/**
 Maps a 3d vector to its normalization:

 v ->  v / ||v||

 @author Matthieu Nesme
 @date 2016

*/
template <class T >
class SOFA_Compliant_API NormalizationMapping : public AssembledMapping<T, T>
{
  public:
    SOFA_CLASS(SOFA_TEMPLATE(NormalizationMapping,T), SOFA_TEMPLATE2(AssembledMapping,T,T));
	
    typedef NormalizationMapping<T> self;
    typedef typename T::Coord Coord;
    typedef typename T::Real Real;

    typedef helper::vector<unsigned> Indices;
    Data<Indices> d_indices;

	
    NormalizationMapping()
        : d_indices( initData(&d_indices, "indices", "indices of vector to normalize") )
    {}

    enum {N = T::deriv_total_size };

    virtual void init()
    {
        reinit();
        Inherit1::init();
    }

    virtual void reinit()
    {
        helper::ReadAccessor< Data<helper::vector<unsigned> > > indices(d_indices);
        size_t size = indices.empty() ? this->getFromModel()->getSize() : indices.size(); // if indices is empty, mapping every input dofs

        this->getToModel()->resize( size );
        Inherit1::reinit();
    }

	virtual void apply(typename self::out_pos_type& out, 
	                   const typename self::in_pos_type& in )  {

        helper::ReadAccessor< Data<helper::vector<unsigned> > > indices(d_indices);
        size_t size = indices.empty() ? this->getFromModel()->getSize() : indices.size(); // if indices is empty, mapping every input dofs

        assert( out.size() == size );

        for( size_t j = 0; j < size; ++j)
        {
            const unsigned& index = indices.empty() ? j : indices[j] ;
            out[j] = in[index].normalized(); // todo keep norm computation for Jacobian and Hessian
        }
	}

	virtual void assemble( const typename self::in_pos_type& in ) {

        helper::ReadAccessor< Data<helper::vector<unsigned> > > indices(d_indices);
        size_t size = indices.empty() ? this->getFromModel()->getSize() : indices.size(); // if indices is empty, mapping every input dofs

        typename self::jacobian_type::CompressedMatrix& J = this->jacobian.compressedMatrix;
        this->jacobian.resizeBlocks( size, in.size() );
        J.reserve(size*N*N);

        for(size_t k = 0; k < size; ++k)
        {
            const unsigned& index = indices.empty() ? k : indices[k] ;
            const Coord& v = in[index];


            Real t1 = v[2] * v[2];
            Real t2 = v[0] * v[0];
            Real t3 = v[1] * v[1];
            Real t4 = t1 + t2 + t3;
            Real t5 = 1. / ( t4 * sqrt(t4) ); //pow(t4, -0.3e1 / 0.2e1);
            t4 = t4 * t5;
            Real t6 = v[1] * t5 * v[0];
            Real t7 = v[2] * t5;
            Real t8 = t7 * v[0];
            t7 = t7 * v[1];

            J.startVec( k*N );
            J.insertBack(k*N  , index*N   ) = -t2 * t5 + t4;
            J.insertBack(k*N  , index*N+1 ) = -t6;
            J.insertBack(k*N  , index*N+2 ) = -t8;

            J.startVec( k*N+1 );
            J.insertBack(k*N+1, index*N   ) = -t6;
            J.insertBack(k*N+1, index*N+1 ) = -t3 * t5 + t4;
            J.insertBack(k*N+1, index*N+2 ) = -t7;

            J.startVec( k*N+2 );
            J.insertBack(k*N+2, index*N   ) = -t8;
            J.insertBack(k*N+2, index*N+1 ) = -t7;
            J.insertBack(k*N+2, index*N+2 ) = -t1 * t5 + t4;
        }
        J.finalize();
	}


//    virtual void assemble_geometric( const typename self::in_pos_type& in, const typename self::out_force_type& out )
//    {
//        The code is generated by maple, so itshould be ok, but does not correspond to the finite differences performed in Mapping_test
//        To be fixed to be used in a stiff constraint
//
//        helper::ReadAccessor< Data<helper::vector<unsigned> > > indices(d_indices);
//        size_t size = indices.empty() ? this->getFromModel()->getSize() : indices.size(); // if indices is empty, mapping every input dofs

//        typedef defaulttype::Mat<9,3,Real> Mat93;
//        typedef defaulttype::Vec<9,Real> Vec9;

//        typename self::geometric_type::CompressedMatrix& K = this->geometric.compressedMatrix;
//        this->geometric.resizeBlocks( in.size(), in.size() );
//        K.reserve(in.size()*N*N);

//        // temp
//        Mat93 M;
//        Vec9 dd;

//        for(size_t i = 0; i < size; ++i)
//        {
//            const unsigned& index = indices.empty() ? i : indices[i] ;

//            const Coord& childForce = out[i];

//            const Coord& v = in[index];
//            const Real& x = v[0];
//            const Real& y = v[1];
//            const Real& z = v[2];

//            Real t1 = z * z;
//            Real t2 = x * x;
//            Real t3 = y * y;
//            Real t4 = t2 + t3 + t1;
//            Real t5 = pow(t4, -0.5e1 / 0.2e1);
//            Real t40 = t4 * t5;
//            Real t20 = t2 * t5;
//            Real t6 = 0.3e1 * t20 - t40;
//            Real t7 = y * t6;
//            t6 = z * t6;
//            Real t8 = 0.3e1 * y * t5 * x * z;

//            M[0][0] = -0.3e1 * x * (-t20 + t40);
//            M[1][0] = t7;
//            M[2][0] = t6;
//            M[3][0] = t7;
//            M[4][0] = x * (0.3e1 * t3 * t5 - t40);
//            M[5][0] = t8;
//            M[6][0] = t6;
//            M[7][0] = t8;
//            M[8][0] = x * (0.3e1 * t1 * t5 - t40);



//            Real t30 = t3 * t5;
//            t6 = -t4 + 0.3e1 * t30;
//            t7 = x * t6;
//            t8 = 0.3e1 * y * t5 * x * z;
//            t6 = z * t6;
//            M[0][1] = y * (0.3e1 * t2 * t5 - t4);
//            M[1][1] = t7;
//            M[2][1] = t8;
//            M[3][1] = t7;
//            M[4][1] = -0.3e1 * y * (t4 - t30);
//            M[5][1] = t6;
//            M[6][1] = t8;
//            M[7][1] = t6;
//            M[8][1] = y * (0.3e1 * t5 * t1 - t4);



//            t1 = t1 * t5;
//            t6 = 0.3e1 * t1 - t4;
//            t7 = x * t6;
//            t8 = 0.3e1 * y * t5 * x * z;
//            t6 = y * t6;
//            M[0][2] = z * (0.3e1 * t2 * t5 - t4);
//            M[1][2] = t8;
//            M[2][2] = t7;
//            M[3][2] = t8;
//            M[4][2] = z * (0.3e1 * t3 * t5 - t4);
//            M[5][2] = t6;
//            M[6][2] = t7;
//            M[7][2] = t6;
//            M[8][2] = -0.3e1 * z * (-t1 + t4);

//            dd = M * childForce;


//            K.startVec( index*N );
//            K.insertBack(index*N  , index*N   ) = dd[0];
//            K.insertBack(index*N  , index*N+1 ) = dd[1];
//            K.insertBack(index*N  , index*N+2 ) = dd[2];

//            K.startVec( index*N+1 );
//            K.insertBack(index*N+1, index*N   ) = dd[3];
//            K.insertBack(index*N+1, index*N+1 ) = dd[4];
//            K.insertBack(index*N+1, index*N+2 ) = dd[5];

//            K.startVec( index*N+2 );
//            K.insertBack(index*N+2, index*N   ) = dd[6];
//            K.insertBack(index*N+2, index*N+1 ) = dd[7];
//            K.insertBack(index*N+2, index*N+2 ) = dd[8];
//        }
//        K.finalize();
//    }

};



}
}
}


#endif
